{"version":3,"sources":["logo.svg","loading.svg","Button.tsx","AlbumCover.tsx","SoundPreview.tsx","App.tsx","registerServiceWorker.tsx","index.tsx"],"names":["module","exports","Button","onClick","children","AlbumCover","track","undefined","src","album","images","url","alt","Sound","require","default","SoundPreview","playSound","previewUrl","playStatus","status","PLAYING","EmptyTrack","name","id","height","preview_url","getRandomNumber","x","excludeNumbers","randomNumber","Math","floor","random","includes","App","timeout","useState","songsLoaded","setSongsLoaded","tracks","setTracks","playing","setPlaying","currentTrack","setCurrentTrack","currentTrackIndex","setCurrentTrackIndex","useEffect","fetch","method","headers","Authorization","then","response","json","data","console","log","items","length","setTimeout","getNewTrack","randomIndex","secondTrackIndex","thirdTrackIndex","firstTrack","secondTrack","thirdTrack","propositions","array","i","j","shuffleArray","className","logo","loading","map","clearTimeout","swal","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","catch","error","ReactDOM","document","getElementById","URL","process","toString","origin","addEventListener","get","indexOf","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"gHAAAA,EAAOC,QAAU,IAA0B,kC,mBCA3CD,EAAOC,QAAU,IAA0B,qC,8NCU5BC,G,YAFA,SAAC,GAAD,IAAGC,EAAH,EAAGA,QAASC,EAAZ,EAAYA,SAAZ,OAAwC,0BAAQD,QAASA,GAAUC,KCDnE,SAASC,EAAT,GAAiD,IAAD,EAA1BC,EAA0B,EAA1BA,MACnC,YAAcC,IAAVD,EAA4B,KACzB,uBAAKE,IAAG,UAAEF,EAAMG,MAAMC,OAAO,UAArB,aAAE,EAAuBC,IAAKC,IAAI,KCRnD,IAAMC,EAAQC,EAAQ,IAAeC,QAOtB,SAASC,EAAT,GAAqE,IAA7CC,EAA4C,EAA5CA,UAAWC,EAAiC,EAAjCA,WAChD,YAAmBX,IAAfW,EAAiC,KACjCD,EACK,gBAACJ,EAAD,CAAOF,IAAKO,EAAYC,WAAYN,EAAMO,OAAOC,UAEnD,KCHT,IAGMC,EAAoB,CACxBC,KAAM,GACNC,GAAI,GACJf,MAAO,CAAEC,OAAQ,CAAC,CAAEe,OAAQ,EAAGd,IAAK,MACpCe,YAAa,IAYf,SAASC,EAAgBC,EAAWC,GAClC,IAAIC,EAAeC,KAAKC,MAAMD,KAAKE,SAAWL,GAC9C,QAAuBrB,IAAnBsB,EACF,OAAOC,EAET,KAAOD,EAAeK,SAASJ,IAC7BA,EAAeC,KAAKC,MAAMD,KAAKE,SAAWL,GAE5C,OAAOE,EA4BT,IA4FeK,EA5FH,WAAO,IAAD,gBAOZC,EAPY,EACsBC,oBAAS,GAD/B,mBACTC,EADS,KACIC,EADJ,OAEYF,qBAFZ,mBAETG,EAFS,KAEDC,EAFC,OAGcJ,oBAAS,GAHvB,mBAGTK,EAHS,KAGAC,EAHA,OAIwBN,qBAJxB,mBAITO,EAJS,KAIKC,EAJL,OAKkCR,oBAAkB,GALpD,mBAKTS,EALS,KAKUC,EALV,KAQhBC,qBAAU,WACRC,MAAM,uCAAwC,CAC5CC,OAAQ,MACRC,QAAS,CACPC,cAAe,6LAGhBC,MAAK,SAACC,GAAD,OAAcA,EAASC,UAC5BF,MAAK,SAACG,GAA8B,IAAD,EAClCC,QAAQC,IAAIF,GACZf,EAAUe,EAAKG,OACfZ,EAAqBpB,EAAgB6B,EAAKG,MAAMC,SAChDf,EAAe,UAACW,EAAKG,MAAMb,UAAZ,aAAC,EAA+BxC,UAEnDiC,GAAe,GACfH,EAAUyB,YAAW,kBAAMC,MAAe,OACzC,IAEH,IASMA,EAAc,WAAO,IAAD,EACxB,GAAKtB,EAAL,CAGA,IAAMuB,EAAcpC,EAAgBa,EAAOoB,OAAQ,CAACd,IACpDC,EAAqBgB,GACrBlB,EAAe,OAACL,QAAD,IAACA,GAAD,UAACA,EAASuB,UAAV,aAAC,EAAuBzD,SAInC0D,EAAmBrC,EAAe,iBAACa,QAAD,IAACA,OAAD,EAACA,EAAQoB,cAAT,QAAmB,EAAG,CAACd,IACzDmB,EAAkBtC,EAAe,iBAACa,QAAD,IAACA,OAAD,EAACA,EAAQoB,cAAT,QAAmB,EAAG,CAC3Dd,EACAkB,IAGIE,EAAatB,EACbuB,EAAW,OAAG3B,QAAH,IAAGA,GAAH,UAAGA,EAASwB,UAAZ,aAAG,EAA4B1D,MAC1C8D,EAAU,OAAG5B,QAAH,IAAGA,GAAH,UAAGA,EAASyB,UAAZ,aAAG,EAA2B3D,MAExC+D,EAAe,QACnBH,QADmB,IACnBA,IAAc5C,EADK,OAEnB6C,QAFmB,IAEnBA,IAAe7C,EAFI,OAGnB8C,QAHmB,IAGnBA,IAAc9C,GAKhB,OA5GF,SAAsBgD,GACpB,QAAc/D,IAAV+D,EACJ,IAAK,IAAIC,EAAID,EAAMV,OAAS,EAAGW,EAAI,EAAGA,IAAK,CAAC,IAAD,IACnCC,EAAIzC,KAAKC,MAAMD,KAAKE,UAAYsC,EAAI,IADD,EAEjB,WAACD,EAAME,UAAP,QAAalD,EAAb,UAAyBgD,EAAMC,UAA/B,QAAqCjD,GAA3DgD,EAAMC,GAFiC,KAE7BD,EAAME,GAFuB,MAwG3CC,CAAaJ,GAGX,uBAAKK,UAAU,OACb,0BAAQA,UAAU,cAChB,uBAAKlE,IAAKmE,IAAMD,UAAU,WAAW9D,IAAI,SACzC,sBAAI8D,UAAU,aAAd,iCAA8ClC,QAA9C,IAA8CA,OAA9C,EAA8CA,EAAQoB,OAAtD,eAEF,uBAAKc,UAAU,cACZpC,EACC,gCACE,gBAACjC,EAAD,CAAYC,MAAK,iBAAEkC,QAAF,IAAEA,GAAF,UAAEA,EAAS,UAAX,aAAE,EAAalC,aAAf,aAAwBC,IACzC,gBAACS,EAAD,CACEC,UAAWyB,EACXxB,WAAU,iBAAEsB,QAAF,IAAEA,GAAF,UAAEA,EAAS,UAAX,aAAE,EAAalC,MAAMoB,mBAArB,aAAoCnB,IAEhD,gBAAC,EAAD,CAAQJ,QAlCA,kBAAMwC,GAAW,KAkCzB,UAGF,uBAAKnC,IAAKoE,IAASF,UAAU,WAAW9D,IAAI,UAGhD,uBAAK8D,UAAU,eACZL,EAAaQ,KAAI,SAACvE,GACjB,OAAO,gBAAC,EAAD,CAAQH,QAAS,YAAiB,OAACG,QAAD,IAACA,OAAD,EAACA,EAAOkB,OA1DjD,OAAKoB,QAAL,IAAKA,OAAL,EAAKA,EAAcpB,KACvBsD,aAAa1C,GACb2C,IAAK,QAAS,iBAAe,WAAW1B,MAAK,kBAAMS,QAEnDiB,IAAK,UAAQ,mCAAiC,WAsDnC,OAAgDzE,QAAhD,IAAgDA,OAAhD,EAAgDA,EAAOiB,YC5IlEyD,EAAcC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DAgCN,SAASC,EAAgBC,GACvBC,UAAUC,cACPC,SAASH,GACTlC,MAAK,SAACsC,GACLA,EAAaC,cAAgB,WAC3B,IAAMC,EAAmBF,EAAaG,WACb,OAArBD,IAGJA,EAAiBE,cAAgB,WACA,cAA3BF,EAAiBG,QACfR,UAAUC,cAAcQ,WAK1BxC,QAAQC,IAAI,6CAKZD,QAAQC,IAAI,6CAMrBwC,OAAM,SAACC,GACN1C,QAAQ0C,MAAM,4CAA6CA,MCtEjEC,SAAgB,gBAAC,EAAD,MAASC,SAASC,eAAe,SDclC,WACb,GAA6C,kBAAmBd,UAAW,CAMzE,GAJkB,IAAIe,IACpBC,qBACAtB,OAAOC,SAASsB,YAEJC,SAAWxB,OAAOC,SAASuB,OAIvC,OAGFxB,OAAOyB,iBAAiB,QAAQ,WAC9B,IAAMpB,EAAK,UAAMiB,qBAAN,sBAEPxB,EA2CV,SAAiCO,GAE/BtC,MAAMsC,GACHlC,MAAK,SAACC,GAAc,IAAD,EAGI,MAApBA,EAASlC,SACwD,KAAjE,UAAAkC,EAASH,QAAQyD,IAAI,uBAArB,eAAsCC,QAAQ,eAG9CrB,UAAUC,cAAcqB,MAAMzD,MAAK,SAACsC,GAClCA,EAAaoB,aAAa1D,MAAK,WAC7B6B,OAAOC,SAAS6B,eAKpB1B,EAAgBC,MAGnBW,OAAM,WACLzC,QAAQC,IACN,oEA/DAuD,CAAwB1B,GAGxBD,EAAgBC,OCnCxB2B,K","file":"static/js/main.3990f68a.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.79f6b6a0.svg\";","module.exports = __webpack_public_path__ + \"static/media/loading.9d4cbf40.svg\";","import \"./Button.css\"\nimport * as React from \"react\"\n\ntype ButtonProps = {\n  onClick: React.MouseEventHandler<HTMLButtonElement> | undefined\n  children: React.ReactNode\n}\n\nconst Button = ({ onClick, children }: ButtonProps) => <button onClick={onClick}>{children}</button>\n\nexport default Button\n","import * as React from \"react\"\nimport { Track } from \"./App\"\n\ntype AlbumCoverProps = {\n  track: Track | undefined\n}\n\nexport default function AlbumCover({ track }: AlbumCoverProps) {\n  if (track === undefined) return null\n  return <img src={track.album.images[0]?.url} alt=\"\" />\n}\n","import * as React from \"react\"\nconst Sound = require(\"react-sound\").default\n\ntype SoundPreviewProps = {\n  playSound: boolean\n  previewUrl: string | undefined\n}\n\nexport default function SoundPreview({ playSound, previewUrl }: SoundPreviewProps) {\n  if (previewUrl === undefined) return null\n  if (playSound) {\n    return <Sound url={previewUrl} playStatus={Sound.status.PLAYING} />\n  }\n  return null\n}\n","import swal from \"sweetalert\"\nimport * as React from \"react\"\nimport logo from \"./logo.svg\"\nimport loading from \"./loading.svg\"\nimport \"./App.css\"\nimport Button from \"./Button\"\nimport { useEffect, useState } from \"react\"\nimport AlbumCover from \"./AlbumCover\"\nimport SoundPreview from \"./SoundPreview\"\n\nconst apiToken =\n  \"BQATr4YXu7krsiCbzjMQxq2YMkK-dPBn8s-CPiyWaTkM7NXvDSHcnw-R7RYduT2ah9LtQ3St3wCcRCmdXxYuYFHdV-CEXnecbSUDqSYQXEP08VFKOnqULhG6HgJAou8V_UeqfRwAv_rnE6aMAwlZXIQG4E2fej9wQwerKD-31lS7rtE8\"\n\nconst EmptyTrack: Track = {\n  name: \"\",\n  id: \"\",\n  album: { images: [{ height: 0, url: \"\" }] },\n  preview_url: \"\",\n}\n\nfunction shuffleArray(array: Track[]) {\n  if (array === undefined) return\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1))\n    ;[array[i], array[j]] = [array[j] ?? EmptyTrack, array[i] ?? EmptyTrack]\n  }\n}\n\n/* Return a random number between 0 included and x excluded */\nfunction getRandomNumber(x: number, excludeNumbers?: number[]) {\n  let randomNumber = Math.floor(Math.random() * x)\n  if (excludeNumbers === undefined) {\n    return randomNumber\n  }\n  while (excludeNumbers.includes(randomNumber)) {\n    randomNumber = Math.floor(Math.random() * x)\n  }\n  return randomNumber\n}\n\ntype SpotifyAPIResponse = {\n  items: Item[]\n}\n\ntype Item = {\n  added_at: Date\n  track: Track\n}\n\nexport type Track = {\n  name: string\n  id: string\n  album: Album\n  preview_url: string\n}\n\ntype Album = {\n  images: AlbumImage[]\n}\n\ntype AlbumImage = {\n  height: number\n  url: string\n}\n\nconst App = () => {\n  const [songsLoaded, setSongsLoaded] = useState(false)\n  const [tracks, setTracks] = useState<Item[]>()\n  const [playing, setPlaying] = useState(false)\n  const [currentTrack, setCurrentTrack] = useState<Track>()\n  const [currentTrackIndex, setCurrentTrackIndex] = useState<number>(-1)\n\n  let timeout: NodeJS.Timeout\n  useEffect(() => {\n    fetch(\"https://api.spotify.com/v1/me/tracks\", {\n      method: \"GET\",\n      headers: {\n        Authorization: \"Bearer \" + apiToken,\n      },\n    })\n      .then((response) => response.json())\n      .then((data: SpotifyAPIResponse) => {\n        console.log(data)\n        setTracks(data.items)\n        setCurrentTrackIndex(getRandomNumber(data.items.length))\n        setCurrentTrack(data.items[currentTrackIndex]?.track)\n      })\n    setSongsLoaded(true)\n    timeout = setTimeout(() => getNewTrack(), 30000)\n  }, [])\n\n  const checkAnswer = (id: string) => {\n    if (id === currentTrack?.id) {\n      clearTimeout(timeout)\n      swal(\"Bravo\", \"Tu as gagné\", \"success\").then(() => getNewTrack())\n    } else {\n      swal(\"Raté\", \"Ce n'est pas la bonne réponse\", \"error\")\n    }\n  }\n\n  const getNewTrack = () => {\n    if (!tracks) {\n      return\n    }\n    const randomIndex = getRandomNumber(tracks.length, [currentTrackIndex])\n    setCurrentTrackIndex(randomIndex)\n    setCurrentTrack(tracks?.[randomIndex]?.track)\n  }\n  const playMusic = () => setPlaying(true)\n\n  const secondTrackIndex = getRandomNumber(tracks?.length ?? 0, [currentTrackIndex])\n  const thirdTrackIndex = getRandomNumber(tracks?.length ?? 0, [\n    currentTrackIndex,\n    secondTrackIndex,\n  ])\n\n  const firstTrack = currentTrack\n  const secondTrack = tracks?.[secondTrackIndex]?.track\n  const thirdTrack = tracks?.[thirdTrackIndex]?.track\n\n  const propositions = [\n    firstTrack ?? EmptyTrack,\n    secondTrack ?? EmptyTrack,\n    thirdTrack ?? EmptyTrack,\n  ]\n\n  shuffleArray(propositions)\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <h1 className=\"App-title\">{`Bonjour, il y a ${tracks?.length} musiques`}</h1>\n      </header>\n      <div className=\"App-images\">\n        {songsLoaded ? (\n          <>\n            <AlbumCover track={tracks?.[0]?.track ?? undefined} />\n            <SoundPreview\n              playSound={playing}\n              previewUrl={tracks?.[0]?.track.preview_url ?? undefined}\n            />\n            <Button onClick={playMusic}>Start</Button>\n          </>\n        ) : (\n          <img src={loading} className=\"App-logo\" alt=\"logo\" />\n        )}\n      </div>\n      <div className=\"App-buttons\">\n        {propositions.map((track) => {\n          return <Button onClick={() => checkAnswer(track?.id)}>{track?.name}</Button>\n        })}\n      </div>\n    </div>\n  )\n}\n\nexport default App\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport default function register() {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.toString()\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl);\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker === null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log(\"New content is available; please refresh.\");\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get(\"content-type\")?.indexOf(\"javascript\") === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import * as React from \"react\"\nimport * as ReactDOM from \"react-dom\"\nimport \"./index.css\"\nimport App from \"./App\"\nimport registerServiceWorker from \"./registerServiceWorker\"\n\nReactDOM.render(<App />, document.getElementById(\"root\"))\nregisterServiceWorker()\n"],"sourceRoot":""}